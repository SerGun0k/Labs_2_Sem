#include <iostream>

void copyArray(const int* source, int* destination, int size) {
    for (int i = 0; i < size; i++) {
        destination[i] = source[i];
    }
}

int main() {
    setlocale(LC_ALL, "russian");
    const int N = 10000;
    int* sourceArray = new int[N];
    int* destinationArray = new int[N];

    // Инициализация исходного массива
    for (int i = 0; i < N; i++) {
        sourceArray[i] = i;
    }

    // Копирование массива
    copyArray(sourceArray, destinationArray, N);

    // Вывод результатов для проверки
    std::cout << "Исходный массив: ";
    for (int i = 0; i < N; i++) {
        std::cout << sourceArray[i] << " ";
    }
    std::cout << std::endl;

    std::cout << "Скопированный массив: ";
    for (int i = 0; i < N; i++) {
        std::cout << destinationArray[i] << " ";
    }
    std::cout << std::endl;

    // Освобождение памяти
    delete[] sourceArray;
    delete[] destinationArray;

    return 0;
}


//В C++, эффективным способом копирования массива является использование указателей
//и непосредственного копирования элементов массива.Вот пример кода, который позволяет
//скопировать содержимое одного массива в другой без использования библиотечных функций :
//В этом коде используется функция copyArray, которая принимает указатель на исходный массив, 
//указатель на массив - назначение и размер массива.
//Затем происходит простое копирование элементов массива с помощью цикла for.
//Этот способ копирования эффективен, 
//потому что он обеспечивает прямой доступ к памяти и минимизирует накладные расходы на вызов функций и выполнение сложных операций.
//В C++ указатели предоставляют прямой доступ к памяти, что делает их эффективным средством для копирования массивов.
//Когда вы используете указатели для копирования массива, вы работаете с адресами памяти, 
//где хранятся элементы массива, а не сами элементы.Это позволяет избежать накладных расходов, 
//связанных с вызовом функций или выполнением сложных операций, которые могут быть связаны с использованием библиотечных функций копирования.
//При использовании указателей в цикле for вы можете непосредственно обращаться к каждому 
//элементу исходного массива и копировать его в соответствующий элемент массива - назначения.
//Это простая операция, которая выполняется непосредственно над памятью, что делает ее очень эффективной.
//Однако при использовании указателей необходимо быть осторожными и учитывать правильное выделение и освобождение памяти, 
//чтобы избежать утечек памяти или ошибок доступа.Кроме того, при работе с динамическими массивами следует учитывать,
//что выделенная память должна быть освобождена после использования, чтобы избежать утечек памяти.

//#include <iostream>
//int main() {
//	const int N = 100000;
//	int mas_a[N] = { 1, 2, 3, 4, 5 };
//	int mas_b[N] = {0};
//	for (int i = 0; i < N; i++)
//	{
//		mas_a[i] = i;
//		mas_b[i] = mas_a[i];
//		std::cout << mas_b[i] << " ";
//	}
//
//
//}